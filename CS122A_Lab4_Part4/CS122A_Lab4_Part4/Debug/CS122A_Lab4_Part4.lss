
CS122A_Lab4_Part4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  00000d26  00000dba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d26  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063b  00800122  00800122  00000ddc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ddc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000e0c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001d0  00000000  00000000  00000e4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000022e0  00000000  00000000  0000101c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000eb4  00000000  00000000  000032fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000131f  00000000  00000000  000041b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000047c  00000000  00000000  000054d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d13  00000000  00000000  0000594c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000011bb  00000000  00000000  0000665f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001c8  00000000  00000000  0000781a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
  32:	00 00       	nop
  34:	08 c3       	rjmp	.+1552   	; 0x646 <__vector_13>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e6 e2       	ldi	r30, 0x26	; 38
  a0:	fd e0       	ldi	r31, 0x0D	; 13
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 32       	cpi	r26, 0x22	; 34
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	27 e0       	ldi	r18, 0x07	; 7
  b4:	a2 e2       	ldi	r26, 0x22	; 34
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ad 35       	cpi	r26, 0x5D	; 93
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	5e d1       	rcall	.+700    	; 0x380 <main>
  c4:	2e c6       	rjmp	.+3164   	; 0xd22 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
  cc:	ec 01       	movw	r28, r24
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
  ce:	0e d4       	rcall	.+2076   	; 0x8ec <vTaskSuspendAll>
  d0:	20 91 22 01 	lds	r18, 0x0122	; 0x800122 <__data_end>
  d4:	30 91 23 01 	lds	r19, 0x0123	; 0x800123 <__data_end+0x1>
  d8:	c9 01       	movw	r24, r18
  da:	8c 0f       	add	r24, r28
  dc:	9d 1f       	adc	r25, r29
  de:	8c 3d       	cpi	r24, 0xDC	; 220
  e0:	45 e0       	ldi	r20, 0x05	; 5
  e2:	94 07       	cpc	r25, r20
  e4:	58 f4       	brcc	.+22     	; 0xfc <pvPortMalloc+0x34>
  e6:	28 17       	cp	r18, r24
  e8:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
  ea:	58 f4       	brcc	.+22     	; 0x102 <pvPortMalloc+0x3a>
  ec:	e9 01       	movw	r28, r18
  ee:	cc 5d       	subi	r28, 0xDC	; 220
			xNextFreeByte += xWantedSize;			
  f0:	de 4f       	sbci	r29, 0xFE	; 254
  f2:	90 93 23 01 	sts	0x0123, r25	; 0x800123 <__data_end+0x1>
  f6:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <__data_end>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
  fa:	05 c0       	rjmp	.+10     	; 0x106 <pvPortMalloc+0x3e>
  fc:	c0 e0       	ldi	r28, 0x00	; 0
  fe:	d0 e0       	ldi	r29, 0x00	; 0
 100:	02 c0       	rjmp	.+4      	; 0x106 <pvPortMalloc+0x3e>
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 102:	c0 e0       	ldi	r28, 0x00	; 0
 104:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif	

	return pvReturn;
}
 106:	b9 d4       	rcall	.+2418   	; 0xa7a <xTaskResumeAll>
 108:	ce 01       	movw	r24, r28
 10a:	df 91       	pop	r29
 10c:	cf 91       	pop	r28
 10e:	08 95       	ret

00000110 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 110:	08 95       	ret

00000112 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 112:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 114:	03 96       	adiw	r24, 0x03	; 3
 116:	92 83       	std	Z+2, r25	; 0x02
 118:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 11a:	2f ef       	ldi	r18, 0xFF	; 255
 11c:	3f ef       	ldi	r19, 0xFF	; 255
 11e:	34 83       	std	Z+4, r19	; 0x04
 120:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 122:	96 83       	std	Z+6, r25	; 0x06
 124:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 126:	90 87       	std	Z+8, r25	; 0x08
 128:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 12a:	10 82       	st	Z, r1
 12c:	08 95       	ret

0000012e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 12e:	fc 01       	movw	r30, r24
 130:	11 86       	std	Z+9, r1	; 0x09
 132:	10 86       	std	Z+8, r1	; 0x08
 134:	08 95       	ret

00000136 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 136:	cf 93       	push	r28
 138:	df 93       	push	r29
 13a:	fc 01       	movw	r30, r24
 13c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 13e:	21 81       	ldd	r18, Z+1	; 0x01
 140:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 142:	e9 01       	movw	r28, r18
 144:	8a 81       	ldd	r24, Y+2	; 0x02
 146:	9b 81       	ldd	r25, Y+3	; 0x03
 148:	13 96       	adiw	r26, 0x03	; 3
 14a:	9c 93       	st	X, r25
 14c:	8e 93       	st	-X, r24
 14e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 150:	81 81       	ldd	r24, Z+1	; 0x01
 152:	92 81       	ldd	r25, Z+2	; 0x02
 154:	15 96       	adiw	r26, 0x05	; 5
 156:	9c 93       	st	X, r25
 158:	8e 93       	st	-X, r24
 15a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 15c:	8a 81       	ldd	r24, Y+2	; 0x02
 15e:	9b 81       	ldd	r25, Y+3	; 0x03
 160:	ec 01       	movw	r28, r24
 162:	7d 83       	std	Y+5, r23	; 0x05
 164:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 166:	e9 01       	movw	r28, r18
 168:	7b 83       	std	Y+3, r23	; 0x03
 16a:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 16c:	72 83       	std	Z+2, r23	; 0x02
 16e:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 170:	19 96       	adiw	r26, 0x09	; 9
 172:	fc 93       	st	X, r31
 174:	ee 93       	st	-X, r30
 176:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 178:	80 81       	ld	r24, Z
 17a:	8f 5f       	subi	r24, 0xFF	; 255
 17c:	80 83       	st	Z, r24
}
 17e:	df 91       	pop	r29
 180:	cf 91       	pop	r28
 182:	08 95       	ret

00000184 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 184:	cf 93       	push	r28
 186:	df 93       	push	r29
 188:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 18a:	48 81       	ld	r20, Y
 18c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 18e:	4f 3f       	cpi	r20, 0xFF	; 255
 190:	2f ef       	ldi	r18, 0xFF	; 255
 192:	52 07       	cpc	r21, r18
 194:	31 f4       	brne	.+12     	; 0x1a2 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 196:	dc 01       	movw	r26, r24
 198:	17 96       	adiw	r26, 0x07	; 7
 19a:	ed 91       	ld	r30, X+
 19c:	fc 91       	ld	r31, X
 19e:	18 97       	sbiw	r26, 0x08	; 8
 1a0:	17 c0       	rjmp	.+46     	; 0x1d0 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 1a2:	fc 01       	movw	r30, r24
 1a4:	33 96       	adiw	r30, 0x03	; 3
 1a6:	dc 01       	movw	r26, r24
 1a8:	15 96       	adiw	r26, 0x05	; 5
 1aa:	2d 91       	ld	r18, X+
 1ac:	3c 91       	ld	r19, X
 1ae:	16 97       	sbiw	r26, 0x06	; 6
 1b0:	d9 01       	movw	r26, r18
 1b2:	2d 91       	ld	r18, X+
 1b4:	3c 91       	ld	r19, X
 1b6:	42 17       	cp	r20, r18
 1b8:	53 07       	cpc	r21, r19
 1ba:	50 f0       	brcs	.+20     	; 0x1d0 <vListInsert+0x4c>
 1bc:	02 80       	ldd	r0, Z+2	; 0x02
 1be:	f3 81       	ldd	r31, Z+3	; 0x03
 1c0:	e0 2d       	mov	r30, r0
 1c2:	a2 81       	ldd	r26, Z+2	; 0x02
 1c4:	b3 81       	ldd	r27, Z+3	; 0x03
 1c6:	2d 91       	ld	r18, X+
 1c8:	3c 91       	ld	r19, X
 1ca:	42 17       	cp	r20, r18
 1cc:	53 07       	cpc	r21, r19
 1ce:	b0 f7       	brcc	.-20     	; 0x1bc <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1d0:	a2 81       	ldd	r26, Z+2	; 0x02
 1d2:	b3 81       	ldd	r27, Z+3	; 0x03
 1d4:	bb 83       	std	Y+3, r27	; 0x03
 1d6:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 1d8:	15 96       	adiw	r26, 0x05	; 5
 1da:	dc 93       	st	X, r29
 1dc:	ce 93       	st	-X, r28
 1de:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 1e0:	fd 83       	std	Y+5, r31	; 0x05
 1e2:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 1e4:	d3 83       	std	Z+3, r29	; 0x03
 1e6:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1e8:	99 87       	std	Y+9, r25	; 0x09
 1ea:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1ec:	fc 01       	movw	r30, r24
 1ee:	20 81       	ld	r18, Z
 1f0:	2f 5f       	subi	r18, 0xFF	; 255
 1f2:	20 83       	st	Z, r18
}
 1f4:	df 91       	pop	r29
 1f6:	cf 91       	pop	r28
 1f8:	08 95       	ret

000001fa <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 1fa:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1fc:	a2 81       	ldd	r26, Z+2	; 0x02
 1fe:	b3 81       	ldd	r27, Z+3	; 0x03
 200:	84 81       	ldd	r24, Z+4	; 0x04
 202:	95 81       	ldd	r25, Z+5	; 0x05
 204:	15 96       	adiw	r26, 0x05	; 5
 206:	9c 93       	st	X, r25
 208:	8e 93       	st	-X, r24
 20a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 20c:	a4 81       	ldd	r26, Z+4	; 0x04
 20e:	b5 81       	ldd	r27, Z+5	; 0x05
 210:	82 81       	ldd	r24, Z+2	; 0x02
 212:	93 81       	ldd	r25, Z+3	; 0x03
 214:	13 96       	adiw	r26, 0x03	; 3
 216:	9c 93       	st	X, r25
 218:	8e 93       	st	-X, r24
 21a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 21c:	a0 85       	ldd	r26, Z+8	; 0x08
 21e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 220:	11 96       	adiw	r26, 0x01	; 1
 222:	8d 91       	ld	r24, X+
 224:	9c 91       	ld	r25, X
 226:	12 97       	sbiw	r26, 0x02	; 2
 228:	e8 17       	cp	r30, r24
 22a:	f9 07       	cpc	r31, r25
 22c:	31 f4       	brne	.+12     	; 0x23a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 22e:	84 81       	ldd	r24, Z+4	; 0x04
 230:	95 81       	ldd	r25, Z+5	; 0x05
 232:	12 96       	adiw	r26, 0x02	; 2
 234:	9c 93       	st	X, r25
 236:	8e 93       	st	-X, r24
 238:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 23a:	11 86       	std	Z+9, r1	; 0x09
 23c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 23e:	8c 91       	ld	r24, X
 240:	81 50       	subi	r24, 0x01	; 1
 242:	8c 93       	st	X, r24
 244:	08 95       	ret

00000246 <BUTTONS_Tick>:
        }
}

enum LEDState {INIT,L0} led_state;
void LEDS_Init(){
    led_state = INIT;
 246:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <button_state>
 24a:	81 30       	cpi	r24, 0x01	; 1
 24c:	41 f0       	breq	.+16     	; 0x25e <BUTTONS_Tick+0x18>
 24e:	18 f0       	brcs	.+6      	; 0x256 <BUTTONS_Tick+0x10>
 250:	82 30       	cpi	r24, 0x02	; 2
 252:	59 f0       	breq	.+22     	; 0x26a <BUTTONS_Tick+0x24>
 254:	10 c0       	rjmp	.+32     	; 0x276 <BUTTONS_Tick+0x30>
 256:	81 e0       	ldi	r24, 0x01	; 1
 258:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <button_state>
 25c:	1e c0       	rjmp	.+60     	; 0x29a <BUTTONS_Tick+0x54>
 25e:	00 99       	sbic	0x00, 0	; 0
 260:	1c c0       	rjmp	.+56     	; 0x29a <BUTTONS_Tick+0x54>
 262:	82 e0       	ldi	r24, 0x02	; 2
 264:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <button_state>
 268:	1c c0       	rjmp	.+56     	; 0x2a2 <BUTTONS_Tick+0x5c>
 26a:	00 9b       	sbis	0x00, 0	; 0
 26c:	1a c0       	rjmp	.+52     	; 0x2a2 <BUTTONS_Tick+0x5c>
 26e:	81 e0       	ldi	r24, 0x01	; 1
 270:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <button_state>
 274:	12 c0       	rjmp	.+36     	; 0x29a <BUTTONS_Tick+0x54>
 276:	82 e0       	ldi	r24, 0x02	; 2
 278:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <button_state>
 27c:	12 c0       	rjmp	.+36     	; 0x2a2 <BUTTONS_Tick+0x5c>
 27e:	81 e0       	ldi	r24, 0x01	; 1
 280:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 284:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <reverse_flag>
 288:	88 23       	and	r24, r24
 28a:	19 f0       	breq	.+6      	; 0x292 <BUTTONS_Tick+0x4c>
 28c:	10 92 00 07 	sts	0x0700, r1	; 0x800700 <reverse_flag>
 290:	08 95       	ret
 292:	81 e0       	ldi	r24, 0x01	; 1
 294:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <reverse_flag>
 298:	08 95       	ret
 29a:	15 b8       	out	0x05, r1	; 5
 29c:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
 2a0:	08 95       	ret
 2a2:	8f ef       	ldi	r24, 0xFF	; 255
 2a4:	85 b9       	out	0x05, r24	; 5
 2a6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 2aa:	88 23       	and	r24, r24
 2ac:	41 f3       	breq	.-48     	; 0x27e <BUTTONS_Tick+0x38>
 2ae:	08 95       	ret

000002b0 <ButtonSecTask>:
 2b0:	10 92 5c 07 	sts	0x075C, r1	; 0x80075c <button_state>
 2b4:	c8 df       	rcall	.-112    	; 0x246 <BUTTONS_Tick>
 2b6:	84 e6       	ldi	r24, 0x64	; 100
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	60 d4       	rcall	.+2240   	; 0xb7c <vTaskDelay>
 2bc:	fb cf       	rjmp	.-10     	; 0x2b4 <ButtonSecTask+0x4>

000002be <LEDS_Tick>:
}

void LEDS_Tick(){
    //Transitions
    switch(led_state){
 2be:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <led_state>
 2c2:	88 23       	and	r24, r24
 2c4:	19 f0       	breq	.+6      	; 0x2cc <LEDS_Tick+0xe>
 2c6:	81 30       	cpi	r24, 0x01	; 1
 2c8:	21 f1       	breq	.+72     	; 0x312 <LEDS_Tick+0x54>
 2ca:	04 c0       	rjmp	.+8      	; 0x2d4 <LEDS_Tick+0x16>
        case INIT:
        led_state = L0;
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <led_state>
        break;
 2d2:	1f c0       	rjmp	.+62     	; 0x312 <LEDS_Tick+0x54>
        case L0:
        led_state = L0;
        break;
        default:
        led_state = INIT;
 2d4:	10 92 5b 07 	sts	0x075B, r1	; 0x80075b <led_state>
        break;
    }
    //Actions
    switch(led_state){
        case INIT:
        PORTD = 0;
 2d8:	1b b8       	out	0x0b, r1	; 11
        break;
 2da:	08 95       	ret
        case L0:
        if(PORTD!=0x00)
        {
            if(!reverse_flag)
 2dc:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <reverse_flag>
 2e0:	81 11       	cpse	r24, r1
 2e2:	04 c0       	rjmp	.+8      	; 0x2ec <LEDS_Tick+0x2e>
                PORTD=PORTD<<1;
 2e4:	8b b1       	in	r24, 0x0b	; 11
 2e6:	88 0f       	add	r24, r24
 2e8:	8b b9       	out	0x0b, r24	; 11
 2ea:	08 95       	ret
            else
                PORTD=PORTD>>1;
 2ec:	8b b1       	in	r24, 0x0b	; 11
 2ee:	86 95       	lsr	r24
 2f0:	8b b9       	out	0x0b, r24	; 11
 2f2:	08 95       	ret
        }
        else{
            if(!reverse_flag)
 2f4:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <reverse_flag>
 2f8:	81 11       	cpse	r24, r1
 2fa:	06 c0       	rjmp	.+12     	; 0x308 <LEDS_Tick+0x4a>
            {
                PORTD=0x80;
 2fc:	80 e8       	ldi	r24, 0x80	; 128
 2fe:	8b b9       	out	0x0b, r24	; 11
                reverse_flag=0x01;
 300:	81 e0       	ldi	r24, 0x01	; 1
 302:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <reverse_flag>
 306:	08 95       	ret
            }
            else{
                PORTD=0x01;
 308:	81 e0       	ldi	r24, 0x01	; 1
 30a:	8b b9       	out	0x0b, r24	; 11
                reverse_flag=0x00;
 30c:	10 92 00 07 	sts	0x0700, r1	; 0x800700 <reverse_flag>
            }
        }
        break;
        default:break;
    }
}
 310:	08 95       	ret
    switch(led_state){
        case INIT:
        PORTD = 0;
        break;
        case L0:
        if(PORTD!=0x00)
 312:	8b b1       	in	r24, 0x0b	; 11
 314:	81 11       	cpse	r24, r1
 316:	e2 cf       	rjmp	.-60     	; 0x2dc <LEDS_Tick+0x1e>
 318:	ed cf       	rjmp	.-38     	; 0x2f4 <LEDS_Tick+0x36>

0000031a <LedSecTask>:
    }
}

void LedSecTask()
{
    PORTD=0x01;
 31a:	81 e0       	ldi	r24, 0x01	; 1
 31c:	8b b9       	out	0x0b, r24	; 11
        }
}

enum LEDState {INIT,L0} led_state;
void LEDS_Init(){
    led_state = INIT;
 31e:	10 92 5b 07 	sts	0x075B, r1	; 0x80075b <led_state>
    PORTD=0x01;
    LEDS_Init();
    for(;;)
    {
        LEDS_Tick();
        vTaskDelay(125);
 322:	cd df       	rcall	.-102    	; 0x2be <LEDS_Tick>
 324:	8d e7       	ldi	r24, 0x7D	; 125
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	29 d4       	rcall	.+2130   	; 0xb7c <vTaskDelay>
 32a:	fb cf       	rjmp	.-10     	; 0x322 <LedSecTask+0x8>

0000032c <StartSecPulse>:
    }
}

void StartSecPulse(unsigned portBASE_TYPE Priority)
{
 32c:	af 92       	push	r10
 32e:	bf 92       	push	r11
 330:	cf 92       	push	r12
 332:	df 92       	push	r13
 334:	ef 92       	push	r14
 336:	ff 92       	push	r15
 338:	0f 93       	push	r16
 33a:	cf 93       	push	r28
    xTaskCreate(LedSecTask, (signed portCHAR *)"LedSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
 33c:	a1 2c       	mov	r10, r1
 33e:	b1 2c       	mov	r11, r1
 340:	c1 2c       	mov	r12, r1
 342:	d1 2c       	mov	r13, r1
 344:	e1 2c       	mov	r14, r1
 346:	f1 2c       	mov	r15, r1
 348:	08 2f       	mov	r16, r24
 34a:	20 e0       	ldi	r18, 0x00	; 0
 34c:	30 e0       	ldi	r19, 0x00	; 0
 34e:	45 e5       	ldi	r20, 0x55	; 85
 350:	50 e0       	ldi	r21, 0x00	; 0
 352:	63 e0       	ldi	r22, 0x03	; 3
 354:	71 e0       	ldi	r23, 0x01	; 1
 356:	8d e8       	ldi	r24, 0x8D	; 141
 358:	91 e0       	ldi	r25, 0x01	; 1
 35a:	ac d1       	rcall	.+856    	; 0x6b4 <xTaskGenericCreate>
    xTaskCreate(ButtonSecTask, (signed portCHAR *)"ButtonSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
 35c:	20 e0       	ldi	r18, 0x00	; 0
 35e:	30 e0       	ldi	r19, 0x00	; 0
 360:	45 e5       	ldi	r20, 0x55	; 85
 362:	50 e0       	ldi	r21, 0x00	; 0
 364:	6e e0       	ldi	r22, 0x0E	; 14
 366:	71 e0       	ldi	r23, 0x01	; 1
 368:	88 e5       	ldi	r24, 0x58	; 88
 36a:	91 e0       	ldi	r25, 0x01	; 1
 36c:	a3 d1       	rcall	.+838    	; 0x6b4 <xTaskGenericCreate>
}
 36e:	cf 91       	pop	r28
 370:	0f 91       	pop	r16
 372:	ff 90       	pop	r15
 374:	ef 90       	pop	r14
 376:	df 90       	pop	r13
 378:	cf 90       	pop	r12
 37a:	bf 90       	pop	r11
 37c:	af 90       	pop	r10
 37e:	08 95       	ret

00000380 <main>:

int main(void)
{
    DDRA = 0x00; PORTA=0xFF;
 380:	11 b8       	out	0x01, r1	; 1
 382:	8f ef       	ldi	r24, 0xFF	; 255
 384:	82 b9       	out	0x02, r24	; 2
    DDRB=0xFF; PORTB=0x00;
 386:	84 b9       	out	0x04, r24	; 4
 388:	15 b8       	out	0x05, r1	; 5
    DDRD = 0xFF;
 38a:	8a b9       	out	0x0a, r24	; 10
    //Start Tasks
    StartSecPulse(1);
 38c:	81 e0       	ldi	r24, 0x01	; 1
    //RunSchedular
    vTaskStartScheduler();
 38e:	ce df       	rcall	.-100    	; 0x32c <StartSecPulse>
 390:	84 d2       	rcall	.+1288   	; 0x89a <vTaskStartScheduler>
    
    return 0;
 392:	80 e0       	ldi	r24, 0x00	; 0
 394:	90 e0       	ldi	r25, 0x00	; 0
 396:	08 95       	ret

00000398 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 398:	31 e1       	ldi	r19, 0x11	; 17
 39a:	fc 01       	movw	r30, r24
 39c:	30 83       	st	Z, r19
 39e:	31 97       	sbiw	r30, 0x01	; 1
 3a0:	22 e2       	ldi	r18, 0x22	; 34
 3a2:	20 83       	st	Z, r18
 3a4:	31 97       	sbiw	r30, 0x01	; 1
 3a6:	a3 e3       	ldi	r26, 0x33	; 51
 3a8:	a0 83       	st	Z, r26
 3aa:	31 97       	sbiw	r30, 0x01	; 1
 3ac:	60 83       	st	Z, r22
 3ae:	31 97       	sbiw	r30, 0x01	; 1
 3b0:	70 83       	st	Z, r23
 3b2:	31 97       	sbiw	r30, 0x01	; 1
 3b4:	10 82       	st	Z, r1
 3b6:	31 97       	sbiw	r30, 0x01	; 1
 3b8:	60 e8       	ldi	r22, 0x80	; 128
 3ba:	60 83       	st	Z, r22
 3bc:	31 97       	sbiw	r30, 0x01	; 1
 3be:	10 82       	st	Z, r1
 3c0:	31 97       	sbiw	r30, 0x01	; 1
 3c2:	62 e0       	ldi	r22, 0x02	; 2
 3c4:	60 83       	st	Z, r22
 3c6:	31 97       	sbiw	r30, 0x01	; 1
 3c8:	63 e0       	ldi	r22, 0x03	; 3
 3ca:	60 83       	st	Z, r22
 3cc:	31 97       	sbiw	r30, 0x01	; 1
 3ce:	64 e0       	ldi	r22, 0x04	; 4
 3d0:	60 83       	st	Z, r22
 3d2:	31 97       	sbiw	r30, 0x01	; 1
 3d4:	65 e0       	ldi	r22, 0x05	; 5
 3d6:	60 83       	st	Z, r22
 3d8:	31 97       	sbiw	r30, 0x01	; 1
 3da:	66 e0       	ldi	r22, 0x06	; 6
 3dc:	60 83       	st	Z, r22
 3de:	31 97       	sbiw	r30, 0x01	; 1
 3e0:	67 e0       	ldi	r22, 0x07	; 7
 3e2:	60 83       	st	Z, r22
 3e4:	31 97       	sbiw	r30, 0x01	; 1
 3e6:	68 e0       	ldi	r22, 0x08	; 8
 3e8:	60 83       	st	Z, r22
 3ea:	31 97       	sbiw	r30, 0x01	; 1
 3ec:	69 e0       	ldi	r22, 0x09	; 9
 3ee:	60 83       	st	Z, r22
 3f0:	31 97       	sbiw	r30, 0x01	; 1
 3f2:	60 e1       	ldi	r22, 0x10	; 16
 3f4:	60 83       	st	Z, r22
 3f6:	31 97       	sbiw	r30, 0x01	; 1
 3f8:	30 83       	st	Z, r19
 3fa:	31 97       	sbiw	r30, 0x01	; 1
 3fc:	32 e1       	ldi	r19, 0x12	; 18
 3fe:	30 83       	st	Z, r19
 400:	31 97       	sbiw	r30, 0x01	; 1
 402:	33 e1       	ldi	r19, 0x13	; 19
 404:	30 83       	st	Z, r19
 406:	31 97       	sbiw	r30, 0x01	; 1
 408:	34 e1       	ldi	r19, 0x14	; 20
 40a:	30 83       	st	Z, r19
 40c:	31 97       	sbiw	r30, 0x01	; 1
 40e:	35 e1       	ldi	r19, 0x15	; 21
 410:	30 83       	st	Z, r19
 412:	31 97       	sbiw	r30, 0x01	; 1
 414:	36 e1       	ldi	r19, 0x16	; 22
 416:	30 83       	st	Z, r19
 418:	31 97       	sbiw	r30, 0x01	; 1
 41a:	37 e1       	ldi	r19, 0x17	; 23
 41c:	30 83       	st	Z, r19
 41e:	31 97       	sbiw	r30, 0x01	; 1
 420:	38 e1       	ldi	r19, 0x18	; 24
 422:	30 83       	st	Z, r19
 424:	31 97       	sbiw	r30, 0x01	; 1
 426:	39 e1       	ldi	r19, 0x19	; 25
 428:	30 83       	st	Z, r19
 42a:	31 97       	sbiw	r30, 0x01	; 1
 42c:	30 e2       	ldi	r19, 0x20	; 32
 42e:	30 83       	st	Z, r19
 430:	31 97       	sbiw	r30, 0x01	; 1
 432:	31 e2       	ldi	r19, 0x21	; 33
 434:	30 83       	st	Z, r19
 436:	31 97       	sbiw	r30, 0x01	; 1
 438:	20 83       	st	Z, r18
 43a:	31 97       	sbiw	r30, 0x01	; 1
 43c:	23 e2       	ldi	r18, 0x23	; 35
 43e:	20 83       	st	Z, r18
 440:	31 97       	sbiw	r30, 0x01	; 1
 442:	40 83       	st	Z, r20
 444:	31 97       	sbiw	r30, 0x01	; 1
 446:	50 83       	st	Z, r21
 448:	31 97       	sbiw	r30, 0x01	; 1
 44a:	26 e2       	ldi	r18, 0x26	; 38
 44c:	20 83       	st	Z, r18
 44e:	31 97       	sbiw	r30, 0x01	; 1
 450:	27 e2       	ldi	r18, 0x27	; 39
 452:	20 83       	st	Z, r18
 454:	31 97       	sbiw	r30, 0x01	; 1
 456:	28 e2       	ldi	r18, 0x28	; 40
 458:	20 83       	st	Z, r18
 45a:	31 97       	sbiw	r30, 0x01	; 1
 45c:	29 e2       	ldi	r18, 0x29	; 41
 45e:	20 83       	st	Z, r18
 460:	31 97       	sbiw	r30, 0x01	; 1
 462:	20 e3       	ldi	r18, 0x30	; 48
 464:	20 83       	st	Z, r18
 466:	31 97       	sbiw	r30, 0x01	; 1
 468:	21 e3       	ldi	r18, 0x31	; 49
 46a:	20 83       	st	Z, r18
 46c:	86 97       	sbiw	r24, 0x26	; 38
 46e:	08 95       	ret

00000470 <xPortStartScheduler>:
 470:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 474:	8c e7       	ldi	r24, 0x7C	; 124
 476:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 47a:	8b e0       	ldi	r24, 0x0B	; 11
 47c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 480:	ef e6       	ldi	r30, 0x6F	; 111
 482:	f0 e0       	ldi	r31, 0x00	; 0
 484:	80 81       	ld	r24, Z
 486:	82 60       	ori	r24, 0x02	; 2
 488:	80 83       	st	Z, r24
 48a:	a0 91 59 07 	lds	r26, 0x0759	; 0x800759 <pxCurrentTCB>
 48e:	b0 91 5a 07 	lds	r27, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 492:	cd 91       	ld	r28, X+
 494:	cd bf       	out	0x3d, r28	; 61
 496:	dd 91       	ld	r29, X+
 498:	de bf       	out	0x3e, r29	; 62
 49a:	ff 91       	pop	r31
 49c:	ef 91       	pop	r30
 49e:	df 91       	pop	r29
 4a0:	cf 91       	pop	r28
 4a2:	bf 91       	pop	r27
 4a4:	af 91       	pop	r26
 4a6:	9f 91       	pop	r25
 4a8:	8f 91       	pop	r24
 4aa:	7f 91       	pop	r23
 4ac:	6f 91       	pop	r22
 4ae:	5f 91       	pop	r21
 4b0:	4f 91       	pop	r20
 4b2:	3f 91       	pop	r19
 4b4:	2f 91       	pop	r18
 4b6:	1f 91       	pop	r17
 4b8:	0f 91       	pop	r16
 4ba:	ff 90       	pop	r15
 4bc:	ef 90       	pop	r14
 4be:	df 90       	pop	r13
 4c0:	cf 90       	pop	r12
 4c2:	bf 90       	pop	r11
 4c4:	af 90       	pop	r10
 4c6:	9f 90       	pop	r9
 4c8:	8f 90       	pop	r8
 4ca:	7f 90       	pop	r7
 4cc:	6f 90       	pop	r6
 4ce:	5f 90       	pop	r5
 4d0:	4f 90       	pop	r4
 4d2:	3f 90       	pop	r3
 4d4:	2f 90       	pop	r2
 4d6:	1f 90       	pop	r1
 4d8:	0f 90       	pop	r0
 4da:	0f be       	out	0x3f, r0	; 63
 4dc:	0f 90       	pop	r0
 4de:	08 95       	ret
 4e0:	81 e0       	ldi	r24, 0x01	; 1
 4e2:	08 95       	ret

000004e4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 4e4:	0f 92       	push	r0
 4e6:	0f b6       	in	r0, 0x3f	; 63
 4e8:	f8 94       	cli
 4ea:	0f 92       	push	r0
 4ec:	1f 92       	push	r1
 4ee:	11 24       	eor	r1, r1
 4f0:	2f 92       	push	r2
 4f2:	3f 92       	push	r3
 4f4:	4f 92       	push	r4
 4f6:	5f 92       	push	r5
 4f8:	6f 92       	push	r6
 4fa:	7f 92       	push	r7
 4fc:	8f 92       	push	r8
 4fe:	9f 92       	push	r9
 500:	af 92       	push	r10
 502:	bf 92       	push	r11
 504:	cf 92       	push	r12
 506:	df 92       	push	r13
 508:	ef 92       	push	r14
 50a:	ff 92       	push	r15
 50c:	0f 93       	push	r16
 50e:	1f 93       	push	r17
 510:	2f 93       	push	r18
 512:	3f 93       	push	r19
 514:	4f 93       	push	r20
 516:	5f 93       	push	r21
 518:	6f 93       	push	r22
 51a:	7f 93       	push	r23
 51c:	8f 93       	push	r24
 51e:	9f 93       	push	r25
 520:	af 93       	push	r26
 522:	bf 93       	push	r27
 524:	cf 93       	push	r28
 526:	df 93       	push	r29
 528:	ef 93       	push	r30
 52a:	ff 93       	push	r31
 52c:	a0 91 59 07 	lds	r26, 0x0759	; 0x800759 <pxCurrentTCB>
 530:	b0 91 5a 07 	lds	r27, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 534:	0d b6       	in	r0, 0x3d	; 61
 536:	0d 92       	st	X+, r0
 538:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
 53a:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
 53c:	70 d3       	rcall	.+1760   	; 0xc1e <vTaskSwitchContext>
 53e:	a0 91 59 07 	lds	r26, 0x0759	; 0x800759 <pxCurrentTCB>
 542:	b0 91 5a 07 	lds	r27, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 546:	cd 91       	ld	r28, X+
 548:	cd bf       	out	0x3d, r28	; 61
 54a:	dd 91       	ld	r29, X+
 54c:	de bf       	out	0x3e, r29	; 62
 54e:	ff 91       	pop	r31
 550:	ef 91       	pop	r30
 552:	df 91       	pop	r29
 554:	cf 91       	pop	r28
 556:	bf 91       	pop	r27
 558:	af 91       	pop	r26
 55a:	9f 91       	pop	r25
 55c:	8f 91       	pop	r24
 55e:	7f 91       	pop	r23
 560:	6f 91       	pop	r22
 562:	5f 91       	pop	r21
 564:	4f 91       	pop	r20
 566:	3f 91       	pop	r19
 568:	2f 91       	pop	r18
 56a:	1f 91       	pop	r17
 56c:	0f 91       	pop	r16
 56e:	ff 90       	pop	r15
 570:	ef 90       	pop	r14
 572:	df 90       	pop	r13
 574:	cf 90       	pop	r12
 576:	bf 90       	pop	r11
 578:	af 90       	pop	r10
 57a:	9f 90       	pop	r9
 57c:	8f 90       	pop	r8
 57e:	7f 90       	pop	r7
 580:	6f 90       	pop	r6
 582:	5f 90       	pop	r5
 584:	4f 90       	pop	r4
 586:	3f 90       	pop	r3
 588:	2f 90       	pop	r2
 58a:	1f 90       	pop	r1
 58c:	0f 90       	pop	r0
 58e:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
 590:	0f 90       	pop	r0
 592:	08 95       	ret

00000594 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 594:	0f 92       	push	r0
 596:	0f b6       	in	r0, 0x3f	; 63
 598:	f8 94       	cli
 59a:	0f 92       	push	r0
 59c:	1f 92       	push	r1
 59e:	11 24       	eor	r1, r1
 5a0:	2f 92       	push	r2
 5a2:	3f 92       	push	r3
 5a4:	4f 92       	push	r4
 5a6:	5f 92       	push	r5
 5a8:	6f 92       	push	r6
 5aa:	7f 92       	push	r7
 5ac:	8f 92       	push	r8
 5ae:	9f 92       	push	r9
 5b0:	af 92       	push	r10
 5b2:	bf 92       	push	r11
 5b4:	cf 92       	push	r12
 5b6:	df 92       	push	r13
 5b8:	ef 92       	push	r14
 5ba:	ff 92       	push	r15
 5bc:	0f 93       	push	r16
 5be:	1f 93       	push	r17
 5c0:	2f 93       	push	r18
 5c2:	3f 93       	push	r19
 5c4:	4f 93       	push	r20
 5c6:	5f 93       	push	r21
 5c8:	6f 93       	push	r22
 5ca:	7f 93       	push	r23
 5cc:	8f 93       	push	r24
 5ce:	9f 93       	push	r25
 5d0:	af 93       	push	r26
 5d2:	bf 93       	push	r27
 5d4:	cf 93       	push	r28
 5d6:	df 93       	push	r29
 5d8:	ef 93       	push	r30
 5da:	ff 93       	push	r31
 5dc:	a0 91 59 07 	lds	r26, 0x0759	; 0x800759 <pxCurrentTCB>
 5e0:	b0 91 5a 07 	lds	r27, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 5e4:	0d b6       	in	r0, 0x3d	; 61
 5e6:	0d 92       	st	X+, r0
 5e8:	0e b6       	in	r0, 0x3e	; 62
	vTaskIncrementTick();
	vTaskSwitchContext();
 5ea:	0d 92       	st	X+, r0
 5ec:	85 d1       	rcall	.+778    	; 0x8f8 <vTaskIncrementTick>
	portRESTORE_CONTEXT();
 5ee:	17 d3       	rcall	.+1582   	; 0xc1e <vTaskSwitchContext>
 5f0:	a0 91 59 07 	lds	r26, 0x0759	; 0x800759 <pxCurrentTCB>
 5f4:	b0 91 5a 07 	lds	r27, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 5f8:	cd 91       	ld	r28, X+
 5fa:	cd bf       	out	0x3d, r28	; 61
 5fc:	dd 91       	ld	r29, X+
 5fe:	de bf       	out	0x3e, r29	; 62
 600:	ff 91       	pop	r31
 602:	ef 91       	pop	r30
 604:	df 91       	pop	r29
 606:	cf 91       	pop	r28
 608:	bf 91       	pop	r27
 60a:	af 91       	pop	r26
 60c:	9f 91       	pop	r25
 60e:	8f 91       	pop	r24
 610:	7f 91       	pop	r23
 612:	6f 91       	pop	r22
 614:	5f 91       	pop	r21
 616:	4f 91       	pop	r20
 618:	3f 91       	pop	r19
 61a:	2f 91       	pop	r18
 61c:	1f 91       	pop	r17
 61e:	0f 91       	pop	r16
 620:	ff 90       	pop	r15
 622:	ef 90       	pop	r14
 624:	df 90       	pop	r13
 626:	cf 90       	pop	r12
 628:	bf 90       	pop	r11
 62a:	af 90       	pop	r10
 62c:	9f 90       	pop	r9
 62e:	8f 90       	pop	r8
 630:	7f 90       	pop	r7
 632:	6f 90       	pop	r6
 634:	5f 90       	pop	r5
 636:	4f 90       	pop	r4
 638:	3f 90       	pop	r3
 63a:	2f 90       	pop	r2
 63c:	1f 90       	pop	r1
 63e:	0f 90       	pop	r0
 640:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
 642:	0f 90       	pop	r0
 644:	08 95       	ret

00000646 <__vector_13>:
}
 646:	a6 df       	rcall	.-180    	; 0x594 <vPortYieldFromTick>
 648:	18 95       	reti

0000064a <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 64a:	cf 93       	push	r28
 64c:	df 93       	push	r29
 64e:	ec 01       	movw	r28, r24
 650:	e0 91 59 07 	lds	r30, 0x0759	; 0x800759 <pxCurrentTCB>
 654:	f0 91 5a 07 	lds	r31, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 658:	93 83       	std	Z+3, r25	; 0x03
 65a:	82 83       	std	Z+2, r24	; 0x02
 65c:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xTickCount>
 660:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xTickCount+0x1>
 664:	c8 17       	cp	r28, r24
 666:	d9 07       	cpc	r29, r25
 668:	60 f4       	brcc	.+24     	; 0x682 <prvAddCurrentTaskToDelayedList+0x38>
 66a:	60 91 59 07 	lds	r22, 0x0759	; 0x800759 <pxCurrentTCB>
 66e:	70 91 5a 07 	lds	r23, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 672:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxOverflowDelayedTaskList>
 676:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxOverflowDelayedTaskList+0x1>
 67a:	6e 5f       	subi	r22, 0xFE	; 254
 67c:	7f 4f       	sbci	r23, 0xFF	; 255
 67e:	82 dd       	rcall	.-1276   	; 0x184 <vListInsert>
 680:	16 c0       	rjmp	.+44     	; 0x6ae <prvAddCurrentTaskToDelayedList+0x64>
 682:	60 91 59 07 	lds	r22, 0x0759	; 0x800759 <pxCurrentTCB>
 686:	70 91 5a 07 	lds	r23, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 68a:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <pxDelayedTaskList>
 68e:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <pxDelayedTaskList+0x1>
 692:	6e 5f       	subi	r22, 0xFE	; 254
 694:	7f 4f       	sbci	r23, 0xFF	; 255
 696:	76 dd       	rcall	.-1300   	; 0x184 <vListInsert>
 698:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <xNextTaskUnblockTime>
 69c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <xNextTaskUnblockTime+0x1>
 6a0:	c8 17       	cp	r28, r24
 6a2:	d9 07       	cpc	r29, r25
 6a4:	20 f4       	brcc	.+8      	; 0x6ae <prvAddCurrentTaskToDelayedList+0x64>
 6a6:	d0 93 02 01 	sts	0x0102, r29	; 0x800102 <xNextTaskUnblockTime+0x1>
 6aa:	c0 93 01 01 	sts	0x0101, r28	; 0x800101 <xNextTaskUnblockTime>
 6ae:	df 91       	pop	r29
 6b0:	cf 91       	pop	r28
 6b2:	08 95       	ret

000006b4 <xTaskGenericCreate>:
 6b4:	4f 92       	push	r4
 6b6:	5f 92       	push	r5
 6b8:	6f 92       	push	r6
 6ba:	7f 92       	push	r7
 6bc:	8f 92       	push	r8
 6be:	9f 92       	push	r9
 6c0:	af 92       	push	r10
 6c2:	bf 92       	push	r11
 6c4:	cf 92       	push	r12
 6c6:	df 92       	push	r13
 6c8:	ef 92       	push	r14
 6ca:	ff 92       	push	r15
 6cc:	0f 93       	push	r16
 6ce:	1f 93       	push	r17
 6d0:	cf 93       	push	r28
 6d2:	df 93       	push	r29
 6d4:	5c 01       	movw	r10, r24
 6d6:	4b 01       	movw	r8, r22
 6d8:	3a 01       	movw	r6, r20
 6da:	29 01       	movw	r4, r18
 6dc:	81 e2       	ldi	r24, 0x21	; 33
 6de:	90 e0       	ldi	r25, 0x00	; 0
 6e0:	f3 dc       	rcall	.-1562   	; 0xc8 <pvPortMalloc>
 6e2:	ec 01       	movw	r28, r24
 6e4:	89 2b       	or	r24, r25
 6e6:	09 f4       	brne	.+2      	; 0x6ea <xTaskGenericCreate+0x36>
 6e8:	c6 c0       	rjmp	.+396    	; 0x876 <xTaskGenericCreate+0x1c2>
 6ea:	c1 14       	cp	r12, r1
 6ec:	d1 04       	cpc	r13, r1
 6ee:	09 f0       	breq	.+2      	; 0x6f2 <xTaskGenericCreate+0x3e>
 6f0:	be c0       	rjmp	.+380    	; 0x86e <xTaskGenericCreate+0x1ba>
 6f2:	c3 01       	movw	r24, r6
 6f4:	e9 dc       	rcall	.-1582   	; 0xc8 <pvPortMalloc>
 6f6:	98 8f       	std	Y+24, r25	; 0x18
 6f8:	8f 8b       	std	Y+23, r24	; 0x17
 6fa:	00 97       	sbiw	r24, 0x00	; 0
 6fc:	19 f4       	brne	.+6      	; 0x704 <xTaskGenericCreate+0x50>
 6fe:	ce 01       	movw	r24, r28
 700:	07 dd       	rcall	.-1522   	; 0x110 <vPortFree>
 702:	b9 c0       	rjmp	.+370    	; 0x876 <xTaskGenericCreate+0x1c2>
 704:	a3 01       	movw	r20, r6
 706:	65 ea       	ldi	r22, 0xA5	; 165
 708:	70 e0       	ldi	r23, 0x00	; 0
 70a:	f5 d2       	rcall	.+1514   	; 0xcf6 <memset>
 70c:	93 01       	movw	r18, r6
 70e:	21 50       	subi	r18, 0x01	; 1
 710:	31 09       	sbc	r19, r1
 712:	8f 89       	ldd	r24, Y+23	; 0x17
 714:	98 8d       	ldd	r25, Y+24	; 0x18
 716:	3c 01       	movw	r6, r24
 718:	62 0e       	add	r6, r18
 71a:	73 1e       	adc	r7, r19
 71c:	48 e0       	ldi	r20, 0x08	; 8
 71e:	50 e0       	ldi	r21, 0x00	; 0
 720:	b4 01       	movw	r22, r8
 722:	ce 01       	movw	r24, r28
 724:	49 96       	adiw	r24, 0x19	; 25
 726:	ee d2       	rcall	.+1500   	; 0xd04 <strncpy>
 728:	18 a2       	std	Y+32, r1	; 0x20
 72a:	10 2f       	mov	r17, r16
 72c:	04 30       	cpi	r16, 0x04	; 4
 72e:	08 f0       	brcs	.+2      	; 0x732 <xTaskGenericCreate+0x7e>
 730:	13 e0       	ldi	r17, 0x03	; 3
 732:	1e 8b       	std	Y+22, r17	; 0x16
 734:	6e 01       	movw	r12, r28
 736:	82 e0       	ldi	r24, 0x02	; 2
 738:	c8 0e       	add	r12, r24
 73a:	d1 1c       	adc	r13, r1
 73c:	c6 01       	movw	r24, r12
 73e:	f7 dc       	rcall	.-1554   	; 0x12e <vListInitialiseItem>
 740:	ce 01       	movw	r24, r28
 742:	0c 96       	adiw	r24, 0x0c	; 12
 744:	f4 dc       	rcall	.-1560   	; 0x12e <vListInitialiseItem>
 746:	d9 87       	std	Y+9, r29	; 0x09
 748:	c8 87       	std	Y+8, r28	; 0x08
 74a:	84 e0       	ldi	r24, 0x04	; 4
 74c:	90 e0       	ldi	r25, 0x00	; 0
 74e:	81 1b       	sub	r24, r17
 750:	91 09       	sbc	r25, r1
 752:	9d 87       	std	Y+13, r25	; 0x0d
 754:	8c 87       	std	Y+12, r24	; 0x0c
 756:	db 8b       	std	Y+19, r29	; 0x13
 758:	ca 8b       	std	Y+18, r28	; 0x12
 75a:	a2 01       	movw	r20, r4
 75c:	b5 01       	movw	r22, r10
 75e:	c3 01       	movw	r24, r6
 760:	1b de       	rcall	.-970    	; 0x398 <pxPortInitialiseStack>
 762:	99 83       	std	Y+1, r25	; 0x01
 764:	88 83       	st	Y, r24
 766:	e1 14       	cp	r14, r1
 768:	f1 04       	cpc	r15, r1
 76a:	19 f0       	breq	.+6      	; 0x772 <xTaskGenericCreate+0xbe>
 76c:	f7 01       	movw	r30, r14
 76e:	d1 83       	std	Z+1, r29	; 0x01
 770:	c0 83       	st	Z, r28
 772:	0f b6       	in	r0, 0x3f	; 63
 774:	f8 94       	cli
 776:	0f 92       	push	r0
 778:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxCurrentNumberOfTasks>
 77c:	8f 5f       	subi	r24, 0xFF	; 255
 77e:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxCurrentNumberOfTasks>
 782:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <pxCurrentTCB>
 786:	90 91 5a 07 	lds	r25, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 78a:	89 2b       	or	r24, r25
 78c:	69 f5       	brne	.+90     	; 0x7e8 <xTaskGenericCreate+0x134>
 78e:	d0 93 5a 07 	sts	0x075A, r29	; 0x80075a <pxCurrentTCB+0x1>
 792:	c0 93 59 07 	sts	0x0759, r28	; 0x800759 <pxCurrentTCB>
 796:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxCurrentNumberOfTasks>
 79a:	81 30       	cpi	r24, 0x01	; 1
 79c:	a1 f5       	brne	.+104    	; 0x806 <xTaskGenericCreate+0x152>
 79e:	85 e3       	ldi	r24, 0x35	; 53
 7a0:	97 e0       	ldi	r25, 0x07	; 7
 7a2:	b7 dc       	rcall	.-1682   	; 0x112 <vListInitialise>
 7a4:	8e e3       	ldi	r24, 0x3E	; 62
 7a6:	97 e0       	ldi	r25, 0x07	; 7
 7a8:	b4 dc       	rcall	.-1688   	; 0x112 <vListInitialise>
 7aa:	87 e4       	ldi	r24, 0x47	; 71
 7ac:	97 e0       	ldi	r25, 0x07	; 7
 7ae:	b1 dc       	rcall	.-1694   	; 0x112 <vListInitialise>
 7b0:	80 e5       	ldi	r24, 0x50	; 80
 7b2:	97 e0       	ldi	r25, 0x07	; 7
 7b4:	ae dc       	rcall	.-1700   	; 0x112 <vListInitialise>
 7b6:	8c e2       	ldi	r24, 0x2C	; 44
 7b8:	97 e0       	ldi	r25, 0x07	; 7
 7ba:	ab dc       	rcall	.-1706   	; 0x112 <vListInitialise>
 7bc:	83 e2       	ldi	r24, 0x23	; 35
 7be:	97 e0       	ldi	r25, 0x07	; 7
 7c0:	a8 dc       	rcall	.-1712   	; 0x112 <vListInitialise>
 7c2:	86 e1       	ldi	r24, 0x16	; 22
 7c4:	97 e0       	ldi	r25, 0x07	; 7
 7c6:	a5 dc       	rcall	.-1718   	; 0x112 <vListInitialise>
 7c8:	8d e0       	ldi	r24, 0x0D	; 13
 7ca:	97 e0       	ldi	r25, 0x07	; 7
 7cc:	a2 dc       	rcall	.-1724   	; 0x112 <vListInitialise>
 7ce:	8c e2       	ldi	r24, 0x2C	; 44
 7d0:	97 e0       	ldi	r25, 0x07	; 7
 7d2:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <pxDelayedTaskList+0x1>
 7d6:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <pxDelayedTaskList>
 7da:	83 e2       	ldi	r24, 0x23	; 35
 7dc:	97 e0       	ldi	r25, 0x07	; 7
 7de:	90 93 20 07 	sts	0x0720, r25	; 0x800720 <pxOverflowDelayedTaskList+0x1>
 7e2:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <pxOverflowDelayedTaskList>
 7e6:	0f c0       	rjmp	.+30     	; 0x806 <xTaskGenericCreate+0x152>
 7e8:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xSchedulerRunning>
 7ec:	81 11       	cpse	r24, r1
 7ee:	0b c0       	rjmp	.+22     	; 0x806 <xTaskGenericCreate+0x152>
 7f0:	e0 91 59 07 	lds	r30, 0x0759	; 0x800759 <pxCurrentTCB>
 7f4:	f0 91 5a 07 	lds	r31, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 7f8:	86 89       	ldd	r24, Z+22	; 0x16
 7fa:	08 17       	cp	r16, r24
 7fc:	20 f0       	brcs	.+8      	; 0x806 <xTaskGenericCreate+0x152>
 7fe:	d0 93 5a 07 	sts	0x075A, r29	; 0x80075a <pxCurrentTCB+0x1>
 802:	c0 93 59 07 	sts	0x0759, r28	; 0x800759 <pxCurrentTCB>
 806:	8e 89       	ldd	r24, Y+22	; 0x16
 808:	90 91 08 07 	lds	r25, 0x0708	; 0x800708 <uxTopUsedPriority>
 80c:	98 17       	cp	r25, r24
 80e:	10 f4       	brcc	.+4      	; 0x814 <xTaskGenericCreate+0x160>
 810:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxTopUsedPriority>
 814:	90 91 01 07 	lds	r25, 0x0701	; 0x800701 <uxTaskNumber>
 818:	9f 5f       	subi	r25, 0xFF	; 255
 81a:	90 93 01 07 	sts	0x0701, r25	; 0x800701 <uxTaskNumber>
 81e:	90 91 07 07 	lds	r25, 0x0707	; 0x800707 <uxTopReadyPriority>
 822:	98 17       	cp	r25, r24
 824:	10 f4       	brcc	.+4      	; 0x82a <xTaskGenericCreate+0x176>
 826:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <uxTopReadyPriority>
 82a:	90 e0       	ldi	r25, 0x00	; 0
 82c:	9c 01       	movw	r18, r24
 82e:	22 0f       	add	r18, r18
 830:	33 1f       	adc	r19, r19
 832:	22 0f       	add	r18, r18
 834:	33 1f       	adc	r19, r19
 836:	22 0f       	add	r18, r18
 838:	33 1f       	adc	r19, r19
 83a:	82 0f       	add	r24, r18
 83c:	93 1f       	adc	r25, r19
 83e:	b6 01       	movw	r22, r12
 840:	8b 5c       	subi	r24, 0xCB	; 203
 842:	98 4f       	sbci	r25, 0xF8	; 248
 844:	78 dc       	rcall	.-1808   	; 0x136 <vListInsertEnd>
 846:	0f 90       	pop	r0
 848:	0f be       	out	0x3f, r0	; 63
 84a:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xSchedulerRunning>
 84e:	88 23       	and	r24, r24
 850:	51 f0       	breq	.+20     	; 0x866 <xTaskGenericCreate+0x1b2>
 852:	e0 91 59 07 	lds	r30, 0x0759	; 0x800759 <pxCurrentTCB>
 856:	f0 91 5a 07 	lds	r31, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 85a:	86 89       	ldd	r24, Z+22	; 0x16
 85c:	80 17       	cp	r24, r16
 85e:	28 f4       	brcc	.+10     	; 0x86a <xTaskGenericCreate+0x1b6>
 860:	41 de       	rcall	.-894    	; 0x4e4 <vPortYield>
 862:	81 e0       	ldi	r24, 0x01	; 1
 864:	09 c0       	rjmp	.+18     	; 0x878 <xTaskGenericCreate+0x1c4>
 866:	81 e0       	ldi	r24, 0x01	; 1
 868:	07 c0       	rjmp	.+14     	; 0x878 <xTaskGenericCreate+0x1c4>
 86a:	81 e0       	ldi	r24, 0x01	; 1
 86c:	05 c0       	rjmp	.+10     	; 0x878 <xTaskGenericCreate+0x1c4>
 86e:	d8 8e       	std	Y+24, r13	; 0x18
 870:	cf 8a       	std	Y+23, r12	; 0x17
 872:	c6 01       	movw	r24, r12
 874:	47 cf       	rjmp	.-370    	; 0x704 <xTaskGenericCreate+0x50>
 876:	8f ef       	ldi	r24, 0xFF	; 255
 878:	df 91       	pop	r29
 87a:	cf 91       	pop	r28
 87c:	1f 91       	pop	r17
 87e:	0f 91       	pop	r16
 880:	ff 90       	pop	r15
 882:	ef 90       	pop	r14
 884:	df 90       	pop	r13
 886:	cf 90       	pop	r12
 888:	bf 90       	pop	r11
 88a:	af 90       	pop	r10
 88c:	9f 90       	pop	r9
 88e:	8f 90       	pop	r8
 890:	7f 90       	pop	r7
 892:	6f 90       	pop	r6
 894:	5f 90       	pop	r5
 896:	4f 90       	pop	r4
 898:	08 95       	ret

0000089a <vTaskStartScheduler>:
 89a:	af 92       	push	r10
 89c:	bf 92       	push	r11
 89e:	cf 92       	push	r12
 8a0:	df 92       	push	r13
 8a2:	ef 92       	push	r14
 8a4:	ff 92       	push	r15
 8a6:	0f 93       	push	r16
 8a8:	a1 2c       	mov	r10, r1
 8aa:	b1 2c       	mov	r11, r1
 8ac:	c1 2c       	mov	r12, r1
 8ae:	d1 2c       	mov	r13, r1
 8b0:	e1 2c       	mov	r14, r1
 8b2:	f1 2c       	mov	r15, r1
 8b4:	00 e0       	ldi	r16, 0x00	; 0
 8b6:	20 e0       	ldi	r18, 0x00	; 0
 8b8:	30 e0       	ldi	r19, 0x00	; 0
 8ba:	45 e5       	ldi	r20, 0x55	; 85
 8bc:	50 e0       	ldi	r21, 0x00	; 0
 8be:	6c e1       	ldi	r22, 0x1C	; 28
 8c0:	71 e0       	ldi	r23, 0x01	; 1
 8c2:	89 ed       	ldi	r24, 0xD9	; 217
 8c4:	95 e0       	ldi	r25, 0x05	; 5
 8c6:	f6 de       	rcall	.-532    	; 0x6b4 <xTaskGenericCreate>
 8c8:	81 30       	cpi	r24, 0x01	; 1
 8ca:	41 f4       	brne	.+16     	; 0x8dc <vTaskStartScheduler+0x42>
 8cc:	f8 94       	cli
 8ce:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xSchedulerRunning>
 8d2:	10 92 0a 07 	sts	0x070A, r1	; 0x80070a <xTickCount+0x1>
 8d6:	10 92 09 07 	sts	0x0709, r1	; 0x800709 <xTickCount>
 8da:	ca dd       	rcall	.-1132   	; 0x470 <xPortStartScheduler>
 8dc:	0f 91       	pop	r16
 8de:	ff 90       	pop	r15
 8e0:	ef 90       	pop	r14
 8e2:	df 90       	pop	r13
 8e4:	cf 90       	pop	r12
 8e6:	bf 90       	pop	r11
 8e8:	af 90       	pop	r10
 8ea:	08 95       	ret

000008ec <vTaskSuspendAll>:
 8ec:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxSchedulerSuspended>
 8f0:	8f 5f       	subi	r24, 0xFF	; 255
 8f2:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxSchedulerSuspended>
 8f6:	08 95       	ret

000008f8 <vTaskIncrementTick>:
 8f8:	0f 93       	push	r16
 8fa:	1f 93       	push	r17
 8fc:	cf 93       	push	r28
 8fe:	df 93       	push	r29
 900:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxSchedulerSuspended>
 904:	81 11       	cpse	r24, r1
 906:	af c0       	rjmp	.+350    	; 0xa66 <vTaskIncrementTick+0x16e>
 908:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xTickCount>
 90c:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xTickCount+0x1>
 910:	01 96       	adiw	r24, 0x01	; 1
 912:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <xTickCount+0x1>
 916:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xTickCount>
 91a:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xTickCount>
 91e:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xTickCount+0x1>
 922:	89 2b       	or	r24, r25
 924:	99 f5       	brne	.+102    	; 0x98c <vTaskIncrementTick+0x94>
 926:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <pxDelayedTaskList>
 92a:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <pxDelayedTaskList+0x1>
 92e:	20 91 1f 07 	lds	r18, 0x071F	; 0x80071f <pxOverflowDelayedTaskList>
 932:	30 91 20 07 	lds	r19, 0x0720	; 0x800720 <pxOverflowDelayedTaskList+0x1>
 936:	30 93 22 07 	sts	0x0722, r19	; 0x800722 <pxDelayedTaskList+0x1>
 93a:	20 93 21 07 	sts	0x0721, r18	; 0x800721 <pxDelayedTaskList>
 93e:	90 93 20 07 	sts	0x0720, r25	; 0x800720 <pxOverflowDelayedTaskList+0x1>
 942:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <pxOverflowDelayedTaskList>
 946:	80 91 02 07 	lds	r24, 0x0702	; 0x800702 <xNumOfOverflows>
 94a:	8f 5f       	subi	r24, 0xFF	; 255
 94c:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <xNumOfOverflows>
 950:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxDelayedTaskList>
 954:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxDelayedTaskList+0x1>
 958:	80 81       	ld	r24, Z
 95a:	81 11       	cpse	r24, r1
 95c:	07 c0       	rjmp	.+14     	; 0x96c <vTaskIncrementTick+0x74>
 95e:	8f ef       	ldi	r24, 0xFF	; 255
 960:	9f ef       	ldi	r25, 0xFF	; 255
 962:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <xNextTaskUnblockTime+0x1>
 966:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <xNextTaskUnblockTime>
 96a:	10 c0       	rjmp	.+32     	; 0x98c <vTaskIncrementTick+0x94>
 96c:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxDelayedTaskList>
 970:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxDelayedTaskList+0x1>
 974:	05 80       	ldd	r0, Z+5	; 0x05
 976:	f6 81       	ldd	r31, Z+6	; 0x06
 978:	e0 2d       	mov	r30, r0
 97a:	06 80       	ldd	r0, Z+6	; 0x06
 97c:	f7 81       	ldd	r31, Z+7	; 0x07
 97e:	e0 2d       	mov	r30, r0
 980:	82 81       	ldd	r24, Z+2	; 0x02
 982:	93 81       	ldd	r25, Z+3	; 0x03
 984:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <xNextTaskUnblockTime+0x1>
 988:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <xNextTaskUnblockTime>
 98c:	20 91 09 07 	lds	r18, 0x0709	; 0x800709 <xTickCount>
 990:	30 91 0a 07 	lds	r19, 0x070A	; 0x80070a <xTickCount+0x1>
 994:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <xNextTaskUnblockTime>
 998:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <xNextTaskUnblockTime+0x1>
 99c:	28 17       	cp	r18, r24
 99e:	39 07       	cpc	r19, r25
 9a0:	08 f4       	brcc	.+2      	; 0x9a4 <vTaskIncrementTick+0xac>
 9a2:	66 c0       	rjmp	.+204    	; 0xa70 <vTaskIncrementTick+0x178>
 9a4:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxDelayedTaskList>
 9a8:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxDelayedTaskList+0x1>
 9ac:	80 81       	ld	r24, Z
 9ae:	88 23       	and	r24, r24
 9b0:	99 f0       	breq	.+38     	; 0x9d8 <vTaskIncrementTick+0xe0>
 9b2:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxDelayedTaskList>
 9b6:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxDelayedTaskList+0x1>
 9ba:	05 80       	ldd	r0, Z+5	; 0x05
 9bc:	f6 81       	ldd	r31, Z+6	; 0x06
 9be:	e0 2d       	mov	r30, r0
 9c0:	c6 81       	ldd	r28, Z+6	; 0x06
 9c2:	d7 81       	ldd	r29, Z+7	; 0x07
 9c4:	8a 81       	ldd	r24, Y+2	; 0x02
 9c6:	9b 81       	ldd	r25, Y+3	; 0x03
 9c8:	20 91 09 07 	lds	r18, 0x0709	; 0x800709 <xTickCount>
 9cc:	30 91 0a 07 	lds	r19, 0x070A	; 0x80070a <xTickCount+0x1>
 9d0:	28 17       	cp	r18, r24
 9d2:	39 07       	cpc	r19, r25
 9d4:	f8 f4       	brcc	.+62     	; 0xa14 <vTaskIncrementTick+0x11c>
 9d6:	19 c0       	rjmp	.+50     	; 0xa0a <vTaskIncrementTick+0x112>
 9d8:	8f ef       	ldi	r24, 0xFF	; 255
 9da:	9f ef       	ldi	r25, 0xFF	; 255
 9dc:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <xNextTaskUnblockTime+0x1>
 9e0:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <xNextTaskUnblockTime>
 9e4:	45 c0       	rjmp	.+138    	; 0xa70 <vTaskIncrementTick+0x178>
 9e6:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxDelayedTaskList>
 9ea:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxDelayedTaskList+0x1>
 9ee:	05 80       	ldd	r0, Z+5	; 0x05
 9f0:	f6 81       	ldd	r31, Z+6	; 0x06
 9f2:	e0 2d       	mov	r30, r0
 9f4:	c6 81       	ldd	r28, Z+6	; 0x06
 9f6:	d7 81       	ldd	r29, Z+7	; 0x07
 9f8:	8a 81       	ldd	r24, Y+2	; 0x02
 9fa:	9b 81       	ldd	r25, Y+3	; 0x03
 9fc:	20 91 09 07 	lds	r18, 0x0709	; 0x800709 <xTickCount>
 a00:	30 91 0a 07 	lds	r19, 0x070A	; 0x80070a <xTickCount+0x1>
 a04:	28 17       	cp	r18, r24
 a06:	39 07       	cpc	r19, r25
 a08:	28 f4       	brcc	.+10     	; 0xa14 <vTaskIncrementTick+0x11c>
 a0a:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <xNextTaskUnblockTime+0x1>
 a0e:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <xNextTaskUnblockTime>
 a12:	2e c0       	rjmp	.+92     	; 0xa70 <vTaskIncrementTick+0x178>
 a14:	8e 01       	movw	r16, r28
 a16:	0e 5f       	subi	r16, 0xFE	; 254
 a18:	1f 4f       	sbci	r17, 0xFF	; 255
 a1a:	c8 01       	movw	r24, r16
 a1c:	ee db       	rcall	.-2084   	; 0x1fa <vListRemove>
 a1e:	8c 89       	ldd	r24, Y+20	; 0x14
 a20:	9d 89       	ldd	r25, Y+21	; 0x15
 a22:	89 2b       	or	r24, r25
 a24:	19 f0       	breq	.+6      	; 0xa2c <vTaskIncrementTick+0x134>
 a26:	ce 01       	movw	r24, r28
 a28:	0c 96       	adiw	r24, 0x0c	; 12
 a2a:	e7 db       	rcall	.-2098   	; 0x1fa <vListRemove>
 a2c:	8e 89       	ldd	r24, Y+22	; 0x16
 a2e:	90 91 07 07 	lds	r25, 0x0707	; 0x800707 <uxTopReadyPriority>
 a32:	98 17       	cp	r25, r24
 a34:	10 f4       	brcc	.+4      	; 0xa3a <vTaskIncrementTick+0x142>
 a36:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <uxTopReadyPriority>
 a3a:	90 e0       	ldi	r25, 0x00	; 0
 a3c:	9c 01       	movw	r18, r24
 a3e:	22 0f       	add	r18, r18
 a40:	33 1f       	adc	r19, r19
 a42:	22 0f       	add	r18, r18
 a44:	33 1f       	adc	r19, r19
 a46:	22 0f       	add	r18, r18
 a48:	33 1f       	adc	r19, r19
 a4a:	82 0f       	add	r24, r18
 a4c:	93 1f       	adc	r25, r19
 a4e:	b8 01       	movw	r22, r16
 a50:	8b 5c       	subi	r24, 0xCB	; 203
 a52:	98 4f       	sbci	r25, 0xF8	; 248
 a54:	70 db       	rcall	.-2336   	; 0x136 <vListInsertEnd>
 a56:	e0 91 21 07 	lds	r30, 0x0721	; 0x800721 <pxDelayedTaskList>
 a5a:	f0 91 22 07 	lds	r31, 0x0722	; 0x800722 <pxDelayedTaskList+0x1>
 a5e:	80 81       	ld	r24, Z
 a60:	81 11       	cpse	r24, r1
 a62:	c1 cf       	rjmp	.-126    	; 0x9e6 <vTaskIncrementTick+0xee>
 a64:	b9 cf       	rjmp	.-142    	; 0x9d8 <vTaskIncrementTick+0xe0>
 a66:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <uxMissedTicks>
 a6a:	8f 5f       	subi	r24, 0xFF	; 255
 a6c:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <uxMissedTicks>
 a70:	df 91       	pop	r29
 a72:	cf 91       	pop	r28
 a74:	1f 91       	pop	r17
 a76:	0f 91       	pop	r16
 a78:	08 95       	ret

00000a7a <xTaskResumeAll>:
 a7a:	cf 92       	push	r12
 a7c:	df 92       	push	r13
 a7e:	ef 92       	push	r14
 a80:	ff 92       	push	r15
 a82:	0f 93       	push	r16
 a84:	1f 93       	push	r17
 a86:	cf 93       	push	r28
 a88:	df 93       	push	r29
 a8a:	0f b6       	in	r0, 0x3f	; 63
 a8c:	f8 94       	cli
 a8e:	0f 92       	push	r0
 a90:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxSchedulerSuspended>
 a94:	81 50       	subi	r24, 0x01	; 1
 a96:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxSchedulerSuspended>
 a9a:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxSchedulerSuspended>
 a9e:	81 11       	cpse	r24, r1
 aa0:	5f c0       	rjmp	.+190    	; 0xb60 <xTaskResumeAll+0xe6>
 aa2:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxCurrentNumberOfTasks>
 aa6:	81 11       	cpse	r24, r1
 aa8:	2f c0       	rjmp	.+94     	; 0xb08 <xTaskResumeAll+0x8e>
 aaa:	5d c0       	rjmp	.+186    	; 0xb66 <xTaskResumeAll+0xec>
 aac:	d7 01       	movw	r26, r14
 aae:	15 96       	adiw	r26, 0x05	; 5
 ab0:	ed 91       	ld	r30, X+
 ab2:	fc 91       	ld	r31, X
 ab4:	16 97       	sbiw	r26, 0x06	; 6
 ab6:	c6 81       	ldd	r28, Z+6	; 0x06
 ab8:	d7 81       	ldd	r29, Z+7	; 0x07
 aba:	ce 01       	movw	r24, r28
 abc:	0c 96       	adiw	r24, 0x0c	; 12
 abe:	9d db       	rcall	.-2246   	; 0x1fa <vListRemove>
 ac0:	8e 01       	movw	r16, r28
 ac2:	0e 5f       	subi	r16, 0xFE	; 254
 ac4:	1f 4f       	sbci	r17, 0xFF	; 255
 ac6:	c8 01       	movw	r24, r16
 ac8:	98 db       	rcall	.-2256   	; 0x1fa <vListRemove>
 aca:	8e 89       	ldd	r24, Y+22	; 0x16
 acc:	90 91 07 07 	lds	r25, 0x0707	; 0x800707 <uxTopReadyPriority>
 ad0:	98 17       	cp	r25, r24
 ad2:	10 f4       	brcc	.+4      	; 0xad8 <xTaskResumeAll+0x5e>
 ad4:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <uxTopReadyPriority>
 ad8:	90 e0       	ldi	r25, 0x00	; 0
 ada:	9c 01       	movw	r18, r24
 adc:	22 0f       	add	r18, r18
 ade:	33 1f       	adc	r19, r19
 ae0:	22 0f       	add	r18, r18
 ae2:	33 1f       	adc	r19, r19
 ae4:	22 0f       	add	r18, r18
 ae6:	33 1f       	adc	r19, r19
 ae8:	82 0f       	add	r24, r18
 aea:	93 1f       	adc	r25, r19
 aec:	b8 01       	movw	r22, r16
 aee:	8b 5c       	subi	r24, 0xCB	; 203
 af0:	98 4f       	sbci	r25, 0xF8	; 248
 af2:	21 db       	rcall	.-2494   	; 0x136 <vListInsertEnd>
 af4:	e0 91 59 07 	lds	r30, 0x0759	; 0x800759 <pxCurrentTCB>
 af8:	f0 91 5a 07 	lds	r31, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
 afc:	9e 89       	ldd	r25, Y+22	; 0x16
 afe:	86 89       	ldd	r24, Z+22	; 0x16
 b00:	98 17       	cp	r25, r24
 b02:	58 f0       	brcs	.+22     	; 0xb1a <xTaskResumeAll+0xa0>
 b04:	dc 2c       	mov	r13, r12
 b06:	09 c0       	rjmp	.+18     	; 0xb1a <xTaskResumeAll+0xa0>
 b08:	d1 2c       	mov	r13, r1
 b0a:	0f 2e       	mov	r0, r31
 b0c:	f6 e1       	ldi	r31, 0x16	; 22
 b0e:	ef 2e       	mov	r14, r31
 b10:	f7 e0       	ldi	r31, 0x07	; 7
 b12:	ff 2e       	mov	r15, r31
 b14:	f0 2d       	mov	r31, r0
 b16:	cc 24       	eor	r12, r12
 b18:	c3 94       	inc	r12
 b1a:	f7 01       	movw	r30, r14
 b1c:	80 81       	ld	r24, Z
 b1e:	81 11       	cpse	r24, r1
 b20:	c5 cf       	rjmp	.-118    	; 0xaac <xTaskResumeAll+0x32>
 b22:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <uxMissedTicks>
 b26:	88 23       	and	r24, r24
 b28:	79 f0       	breq	.+30     	; 0xb48 <xTaskResumeAll+0xce>
 b2a:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <uxMissedTicks>
 b2e:	88 23       	and	r24, r24
 b30:	91 f0       	breq	.+36     	; 0xb56 <xTaskResumeAll+0xdc>
 b32:	e2 de       	rcall	.-572    	; 0x8f8 <vTaskIncrementTick>
 b34:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <uxMissedTicks>
 b38:	81 50       	subi	r24, 0x01	; 1
 b3a:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <uxMissedTicks>
 b3e:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <uxMissedTicks>
 b42:	81 11       	cpse	r24, r1
 b44:	f6 cf       	rjmp	.-20     	; 0xb32 <xTaskResumeAll+0xb8>
 b46:	07 c0       	rjmp	.+14     	; 0xb56 <xTaskResumeAll+0xdc>
 b48:	f1 e0       	ldi	r31, 0x01	; 1
 b4a:	df 16       	cp	r13, r31
 b4c:	21 f0       	breq	.+8      	; 0xb56 <xTaskResumeAll+0xdc>
 b4e:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xMissedYield>
 b52:	81 30       	cpi	r24, 0x01	; 1
 b54:	39 f4       	brne	.+14     	; 0xb64 <xTaskResumeAll+0xea>
 b56:	10 92 03 07 	sts	0x0703, r1	; 0x800703 <xMissedYield>
 b5a:	c4 dc       	rcall	.-1656   	; 0x4e4 <vPortYield>
 b5c:	81 e0       	ldi	r24, 0x01	; 1
 b5e:	03 c0       	rjmp	.+6      	; 0xb66 <xTaskResumeAll+0xec>
 b60:	80 e0       	ldi	r24, 0x00	; 0
 b62:	01 c0       	rjmp	.+2      	; 0xb66 <xTaskResumeAll+0xec>
 b64:	80 e0       	ldi	r24, 0x00	; 0
 b66:	0f 90       	pop	r0
 b68:	0f be       	out	0x3f, r0	; 63
 b6a:	df 91       	pop	r29
 b6c:	cf 91       	pop	r28
 b6e:	1f 91       	pop	r17
 b70:	0f 91       	pop	r16
 b72:	ff 90       	pop	r15
 b74:	ef 90       	pop	r14
 b76:	df 90       	pop	r13
 b78:	cf 90       	pop	r12
 b7a:	08 95       	ret

00000b7c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 b7c:	cf 93       	push	r28
 b7e:	df 93       	push	r29
 b80:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 b82:	89 2b       	or	r24, r25
		{
			vTaskSuspendAll();
 b84:	91 f0       	breq	.+36     	; 0xbaa <vTaskDelay+0x2e>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 b86:	b2 de       	rcall	.-668    	; 0x8ec <vTaskSuspendAll>
 b88:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xTickCount>
 b8c:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <xTickCount+0x1>
 b90:	c8 0f       	add	r28, r24

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 b92:	d9 1f       	adc	r29, r25
 b94:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <pxCurrentTCB>
 b98:	90 91 5a 07 	lds	r25, 0x075A	; 0x80075a <pxCurrentTCB+0x1>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
			}
			xAlreadyYielded = xTaskResumeAll();
 b9c:	02 96       	adiw	r24, 0x02	; 2
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 b9e:	2d db       	rcall	.-2470   	; 0x1fa <vListRemove>
 ba0:	ce 01       	movw	r24, r28
		{
			portYIELD_WITHIN_API();
 ba2:	53 dd       	rcall	.-1370   	; 0x64a <prvAddCurrentTaskToDelayedList>
 ba4:	6a df       	rcall	.-300    	; 0xa7a <xTaskResumeAll>
		}
	}
 ba6:	81 11       	cpse	r24, r1
 ba8:	01 c0       	rjmp	.+2      	; 0xbac <vTaskDelay+0x30>
 baa:	9c dc       	rcall	.-1736   	; 0x4e4 <vPortYield>
 bac:	df 91       	pop	r29
 bae:	cf 91       	pop	r28
 bb0:	08 95       	ret

00000bb2 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 bb2:	0f 2e       	mov	r0, r31
 bb4:	fd e0       	ldi	r31, 0x0D	; 13
 bb6:	ef 2e       	mov	r14, r31
 bb8:	f7 e0       	ldi	r31, 0x07	; 7
 bba:	ff 2e       	mov	r15, r31
 bbc:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 bbe:	c5 e3       	ldi	r28, 0x35	; 53
 bc0:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 bc2:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxTasksDeleted>
 bc6:	88 23       	and	r24, r24
		{
			vTaskSuspendAll();
 bc8:	29 f1       	breq	.+74     	; 0xc14 <prvIdleTask+0x62>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 bca:	90 de       	rcall	.-736    	; 0x8ec <vTaskSuspendAll>
			xTaskResumeAll();
 bcc:	d7 01       	movw	r26, r14
 bce:	1c 91       	ld	r17, X

			if( xListIsEmpty == pdFALSE )
 bd0:	54 df       	rcall	.-344    	; 0xa7a <xTaskResumeAll>
 bd2:	11 23       	and	r17, r17
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 bd4:	f9 f0       	breq	.+62     	; 0xc14 <prvIdleTask+0x62>
 bd6:	0f b6       	in	r0, 0x3f	; 63
 bd8:	f8 94       	cli
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 bda:	0f 92       	push	r0
 bdc:	d7 01       	movw	r26, r14
 bde:	15 96       	adiw	r26, 0x05	; 5
 be0:	ed 91       	ld	r30, X+
 be2:	fc 91       	ld	r31, X
 be4:	16 97       	sbiw	r26, 0x06	; 6
					vListRemove( &( pxTCB->xGenericListItem ) );
 be6:	06 81       	ldd	r16, Z+6	; 0x06
 be8:	17 81       	ldd	r17, Z+7	; 0x07
 bea:	c8 01       	movw	r24, r16
					--uxCurrentNumberOfTasks;
 bec:	02 96       	adiw	r24, 0x02	; 2
 bee:	05 db       	rcall	.-2550   	; 0x1fa <vListRemove>
 bf0:	80 91 0b 07 	lds	r24, 0x070B	; 0x80070b <uxCurrentNumberOfTasks>
 bf4:	81 50       	subi	r24, 0x01	; 1
					--uxTasksDeleted;
 bf6:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <uxCurrentNumberOfTasks>
 bfa:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxTasksDeleted>
 bfe:	81 50       	subi	r24, 0x01	; 1
				}
				taskEXIT_CRITICAL();
 c00:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <uxTasksDeleted>
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 c04:	0f 90       	pop	r0
 c06:	0f be       	out	0x3f, r0	; 63
		vPortFree( pxTCB );
 c08:	f8 01       	movw	r30, r16
 c0a:	87 89       	ldd	r24, Z+23	; 0x17

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 c0c:	90 8d       	ldd	r25, Z+24	; 0x18
 c0e:	80 da       	rcall	.-2816   	; 0x110 <vPortFree>
 c10:	c8 01       	movw	r24, r16
			{
				taskYIELD();
 c12:	7e da       	rcall	.-2820   	; 0x110 <vPortFree>
 c14:	88 81       	ld	r24, Y
 c16:	82 30       	cpi	r24, 0x02	; 2
 c18:	a0 f2       	brcs	.-88     	; 0xbc2 <prvIdleTask+0x10>
 c1a:	64 dc       	rcall	.-1848   	; 0x4e4 <vPortYield>
 c1c:	d2 cf       	rjmp	.-92     	; 0xbc2 <prvIdleTask+0x10>

00000c1e <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 c1e:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxSchedulerSuspended>
 c22:	81 11       	cpse	r24, r1
 c24:	13 c0       	rjmp	.+38     	; 0xc4c <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 c26:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxTopReadyPriority>
 c2a:	90 e0       	ldi	r25, 0x00	; 0
 c2c:	fc 01       	movw	r30, r24
 c2e:	ee 0f       	add	r30, r30
 c30:	ff 1f       	adc	r31, r31
 c32:	ee 0f       	add	r30, r30
 c34:	ff 1f       	adc	r31, r31
 c36:	ee 0f       	add	r30, r30
 c38:	ff 1f       	adc	r31, r31
 c3a:	8e 0f       	add	r24, r30
 c3c:	9f 1f       	adc	r25, r31
 c3e:	fc 01       	movw	r30, r24
 c40:	eb 5c       	subi	r30, 0xCB	; 203
 c42:	f8 4f       	sbci	r31, 0xF8	; 248
 c44:	80 81       	ld	r24, Z
 c46:	88 23       	and	r24, r24
 c48:	29 f0       	breq	.+10     	; 0xc54 <vTaskSwitchContext+0x36>
 c4a:	1b c0       	rjmp	.+54     	; 0xc82 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 c4c:	81 e0       	ldi	r24, 0x01	; 1
 c4e:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xMissedYield>
 c52:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 c54:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxTopReadyPriority>
 c58:	81 50       	subi	r24, 0x01	; 1
 c5a:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 c5e:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxTopReadyPriority>
 c62:	90 e0       	ldi	r25, 0x00	; 0
 c64:	fc 01       	movw	r30, r24
 c66:	ee 0f       	add	r30, r30
 c68:	ff 1f       	adc	r31, r31
 c6a:	ee 0f       	add	r30, r30
 c6c:	ff 1f       	adc	r31, r31
 c6e:	ee 0f       	add	r30, r30
 c70:	ff 1f       	adc	r31, r31
 c72:	8e 0f       	add	r24, r30
 c74:	9f 1f       	adc	r25, r31
 c76:	fc 01       	movw	r30, r24
 c78:	eb 5c       	subi	r30, 0xCB	; 203
 c7a:	f8 4f       	sbci	r31, 0xF8	; 248
 c7c:	80 81       	ld	r24, Z
 c7e:	88 23       	and	r24, r24
 c80:	49 f3       	breq	.-46     	; 0xc54 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 c82:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxTopReadyPriority>
 c86:	90 e0       	ldi	r25, 0x00	; 0
 c88:	9c 01       	movw	r18, r24
 c8a:	22 0f       	add	r18, r18
 c8c:	33 1f       	adc	r19, r19
 c8e:	22 0f       	add	r18, r18
 c90:	33 1f       	adc	r19, r19
 c92:	22 0f       	add	r18, r18
 c94:	33 1f       	adc	r19, r19
 c96:	28 0f       	add	r18, r24
 c98:	39 1f       	adc	r19, r25
 c9a:	d9 01       	movw	r26, r18
 c9c:	ab 5c       	subi	r26, 0xCB	; 203
 c9e:	b8 4f       	sbci	r27, 0xF8	; 248
 ca0:	11 96       	adiw	r26, 0x01	; 1
 ca2:	ed 91       	ld	r30, X+
 ca4:	fc 91       	ld	r31, X
 ca6:	12 97       	sbiw	r26, 0x02	; 2
 ca8:	02 80       	ldd	r0, Z+2	; 0x02
 caa:	f3 81       	ldd	r31, Z+3	; 0x03
 cac:	e0 2d       	mov	r30, r0
 cae:	12 96       	adiw	r26, 0x02	; 2
 cb0:	fc 93       	st	X, r31
 cb2:	ee 93       	st	-X, r30
 cb4:	11 97       	sbiw	r26, 0x01	; 1
 cb6:	28 5c       	subi	r18, 0xC8	; 200
 cb8:	38 4f       	sbci	r19, 0xF8	; 248
 cba:	e2 17       	cp	r30, r18
 cbc:	f3 07       	cpc	r31, r19
 cbe:	29 f4       	brne	.+10     	; 0xcca <vTaskSwitchContext+0xac>
 cc0:	22 81       	ldd	r18, Z+2	; 0x02
 cc2:	33 81       	ldd	r19, Z+3	; 0x03
 cc4:	fd 01       	movw	r30, r26
 cc6:	32 83       	std	Z+2, r19	; 0x02
 cc8:	21 83       	std	Z+1, r18	; 0x01
 cca:	fc 01       	movw	r30, r24
 ccc:	ee 0f       	add	r30, r30
 cce:	ff 1f       	adc	r31, r31
 cd0:	ee 0f       	add	r30, r30
 cd2:	ff 1f       	adc	r31, r31
 cd4:	ee 0f       	add	r30, r30
 cd6:	ff 1f       	adc	r31, r31
 cd8:	8e 0f       	add	r24, r30
 cda:	9f 1f       	adc	r25, r31
 cdc:	fc 01       	movw	r30, r24
 cde:	eb 5c       	subi	r30, 0xCB	; 203
 ce0:	f8 4f       	sbci	r31, 0xF8	; 248
 ce2:	01 80       	ldd	r0, Z+1	; 0x01
 ce4:	f2 81       	ldd	r31, Z+2	; 0x02
 ce6:	e0 2d       	mov	r30, r0
 ce8:	86 81       	ldd	r24, Z+6	; 0x06
 cea:	97 81       	ldd	r25, Z+7	; 0x07
 cec:	90 93 5a 07 	sts	0x075A, r25	; 0x80075a <pxCurrentTCB+0x1>
 cf0:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <pxCurrentTCB>
 cf4:	08 95       	ret

00000cf6 <memset>:
 cf6:	dc 01       	movw	r26, r24
 cf8:	01 c0       	rjmp	.+2      	; 0xcfc <memset+0x6>
 cfa:	6d 93       	st	X+, r22
 cfc:	41 50       	subi	r20, 0x01	; 1
 cfe:	50 40       	sbci	r21, 0x00	; 0
 d00:	e0 f7       	brcc	.-8      	; 0xcfa <memset+0x4>
 d02:	08 95       	ret

00000d04 <strncpy>:
 d04:	fb 01       	movw	r30, r22
 d06:	dc 01       	movw	r26, r24
 d08:	41 50       	subi	r20, 0x01	; 1
 d0a:	50 40       	sbci	r21, 0x00	; 0
 d0c:	48 f0       	brcs	.+18     	; 0xd20 <strncpy+0x1c>
 d0e:	01 90       	ld	r0, Z+
 d10:	0d 92       	st	X+, r0
 d12:	00 20       	and	r0, r0
 d14:	c9 f7       	brne	.-14     	; 0xd08 <strncpy+0x4>
 d16:	01 c0       	rjmp	.+2      	; 0xd1a <strncpy+0x16>
 d18:	1d 92       	st	X+, r1
 d1a:	41 50       	subi	r20, 0x01	; 1
 d1c:	50 40       	sbci	r21, 0x00	; 0
 d1e:	e0 f7       	brcc	.-8      	; 0xd18 <strncpy+0x14>
 d20:	08 95       	ret

00000d22 <_exit>:
 d22:	f8 94       	cli

00000d24 <__stop_program>:
 d24:	ff cf       	rjmp	.-2      	; 0xd24 <__stop_program>
